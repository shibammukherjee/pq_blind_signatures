

# This file was *autogenerated* from the file rain_hash_instance_gen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_64 = Integer(64); _sage_const_128 = Integer(128); _sage_const_192 = Integer(192); _sage_const_256 = Integer(256); _sage_const_512 = Integer(512); _sage_const_7 = Integer(7); _sage_const_10 = Integer(10); _sage_const_5 = Integer(5); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_80 = Integer(80)
import collections
# might need to install pycryptodomex into sage:
# sage -sh
# pip3 install pycryptodomex
# exit
from Cryptodome.Hash import SHAKE256

if len(sys.argv) != _sage_const_4 :
    print("Usage: <script> <n> <num_rounds> <seed>")
    exit()

n = int(sys.argv[_sage_const_1 ])
num_rounds = int(sys.argv[_sage_const_2 ])
seed = int(sys.argv[_sage_const_3 ])
if n not in [_sage_const_64 , _sage_const_128 , _sage_const_192 , _sage_const_256 , _sage_const_512 ]:
    print("Only n \in \{64, 128, 192, 256, 512\} supported.")
    exit()

F = None
if n == _sage_const_64 :
    F = GF(_sage_const_2 **n, names=('z',)); (z,) = F._first_ngens(1)
elif n == _sage_const_128 :
    F = GF(_sage_const_2 **n, modulus=x**_sage_const_128  + x**_sage_const_7  + x**_sage_const_2  + x + _sage_const_1 , names=('z',)); (z,) = F._first_ngens(1)
elif n == _sage_const_192 :
    F = GF(_sage_const_2 **n, modulus=x**_sage_const_192  + x**_sage_const_7  + x**_sage_const_2  + x + _sage_const_1 , names=('z',)); (z,) = F._first_ngens(1)
elif n == _sage_const_256 :
    F = GF(_sage_const_2 **n, modulus=x**_sage_const_256  + x**_sage_const_10  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 , names=('z',)); (z,) = F._first_ngens(1)
elif n == _sage_const_512 :
    F = GF(_sage_const_2 **n, modulus=x**_sage_const_512  + x**_sage_const_8  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 , names=('z',)); (z,) = F._first_ngens(1)


def gen_random_numbers(state_size,num_rounds,seed):
    shake = SHAKE256.new()
    shake.update('Rain-{}-{}-{}'.format(state_size, num_rounds, seed).encode('utf-8'))
    while True:
        bytes = shake.read(int(state_size/_sage_const_8 ))
        yield int.from_bytes(bytes, byteorder='big')

rand_gen = gen_random_numbers(n, num_rounds, seed)

def rotate_list_right(l, n):
    d = collections.deque(l)
    d.rotate(n)
    return d

def build_lin_perm_poly(n):
    poly_coefficients = [F.fetch_int(next(rand_gen)) for i in range(_sage_const_0 , n)]
    matrix_dickson = matrix(F, [rotate_list_right([poly_coefficients[j]**(_sage_const_2 **i) for j in range(_sage_const_0 , n)], i) for i in range(_sage_const_0 , n)])
    while F.fetch_int(_sage_const_0 ) in poly_coefficients or matrix_dickson.is_invertible() == False:
        poly_coefficients = [F.fetch_int(next(rand_gen)) for i in range(_sage_const_0 , n)]
        matrix_dickson = matrix(F, [rotate_list_right([poly_coefficients[j]**(_sage_const_2 **i) for j in range(_sage_const_0 , n)], i) for i in range(_sage_const_0 , n)])
    return poly_coefficients

def build_inverse_poly(poly_coefficients):
    matrix_dickson = matrix(F, [rotate_list_right([poly_coefficients[j]**(_sage_const_2 **i) for j in range(_sage_const_0 , n)], i) for i in range(_sage_const_0 , n)])
    determinant = matrix_dickson.determinant()
    adjugate = matrix_dickson.adjugate()
    poly_inverse_coefficients = [(_sage_const_1 /determinant) * (adjugate[_sage_const_0 , i]) for i in range(_sage_const_0 , n)]
    return poly_inverse_coefficients

def build_mat_from_poly(poly_coefficients):
    M = matrix(GF(_sage_const_2 ), n, n)

    # Precompute basis and polynomial evaluations
    basis = [F.fetch_int(_sage_const_2 )**(i) for i in range(_sage_const_0 , n)]
    dual_basis = F.dual_basis()
    poly_evaluations = [sum([poly_coefficients[j] * (basis[i]**(_sage_const_2 **j)) for j in range(_sage_const_0 , n)]) for i in range(_sage_const_0 , n)]

    # Construct matrix
    for i in range(_sage_const_0 , n):
        for j in range(_sage_const_0 , n):
            M[i,j] = (dual_basis[i] * poly_evaluations[j]).trace()

    return M

def print_mat(M):
    for i in range(_sage_const_0 ,n):
        for vals in range(_sage_const_0 , n//_sage_const_64 ):
            val = _sage_const_0 
            for j in range(_sage_const_0 ,_sage_const_64 ):
                bit = M[i,vals*_sage_const_64  + j]
                val |= int(bit) << int(j)
            print(hex(val), end=",")
        print()

def build_linear_layer(n):
    poly_coefficients = build_lin_perm_poly(n)
    poly_inverse_coefficients = build_inverse_poly(poly_coefficients)
    while F.fetch_int(_sage_const_0 ) in poly_inverse_coefficients:
        poly_coefficients = build_lin_perm_poly(n)
        poly_inverse_coefficients = build_inverse_poly(poly_coefficients)
    M = build_mat_from_poly(poly_coefficients)
    print("matrix:")
    print_mat(M)
    print("="*_sage_const_80 )
    print("matrix.transposed:")
    print_mat(M.transpose())
    print("="*_sage_const_80 )
    return (M, poly_coefficients)

def permutation(input, round_constants, lin_mats, num_rounds):
    state = input

    # First r-1 rounds
    for i in range(_sage_const_0 , num_rounds):
        # Key and constant addition
        state = state + round_constants[i]
        if state != _sage_const_0 :
            state = state**(-_sage_const_1 )
        state = F.fetch_int(ZZ(list(lin_mats[i][_sage_const_0 ] * vector(state)), base=_sage_const_2 ))
        #state = sum([lin_mats[i][1][j] * (state^(2^j)) for j in range(0, n)])
    
    # # Last round
    # state = state + round_constants[num_rounds - 1]
    # if state != 0:
    #     state = state^(-1)
    # state = state

    return state

print("--- n = " + str(n) + " ---")
print("Irreducible polynomial:", F.modulus())
print("----------")

# Generate round constants
print("--- ROUND CONSTANTS ---")
round_constants = []
for i in range(_sage_const_0 , num_rounds):
    print("Round " + str(i) + ":")
    rc = next(rand_gen)
    round_constants.append(F.fetch_int(rc))
    print(hex(rc))

# Generate linear layers
print("--- LINEAR LAYERS ---")
linear_layers = []
for i in range(_sage_const_0 , num_rounds):
    print("Round " + str(i) + ":")
    (mat, poly_coefficients) = build_linear_layer(n)
    linear_layers.append((mat,poly_coefficients))
    inverse_poly_coefficients = build_inverse_poly(poly_coefficients)
    mat_inverse = build_mat_from_poly(inverse_poly_coefficients)
    print("Matrix:\n" + str(mat))
    print("Linearized polynomial coefficients:\n" + str([hex(coeff.integer_representation()) for coeff in poly_coefficients]))
    print("----------")
    print("Invertible:", mat.is_invertible())
    print("mat_inverse == mat.inverse():", mat_inverse == mat.inverse())
    print("len(poly_coefficients):", str(len(poly_coefficients)))
    print("len(inverse_poly_coefficients):", str(len(inverse_poly_coefficients)))
    print("No 0 in poly_coefficients:", str(F.fetch_int(_sage_const_0 ) not in poly_coefficients))
    print("No 0 in inverse_poly_coefficients:", str(F.fetch_int(_sage_const_0 ) not in inverse_poly_coefficients))

# compute some testvectors:
print("\n\n===TESTVECTORS===")
for i in range(_sage_const_5 ):
    input = F.fetch_int(next(rand_gen))
    # key = F.fetch_int(next(rand_gen))
    output = permutation(input, round_constants, linear_layers, num_rounds)
    print("INPUT:", hex(input.integer_representation()))
    print("OUTPUT:", hex(output.integer_representation()))
    print("-"*_sage_const_80 )

