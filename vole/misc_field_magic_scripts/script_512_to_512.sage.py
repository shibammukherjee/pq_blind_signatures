

# This file was *autogenerated* from the file script_512_to_512.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_8 = Integer(8); _sage_const_5 = Integer(5); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
R = GF(_sage_const_2 )['x']; (x,) = R._first_ngens(1)
E = GF(_sage_const_2 **_sage_const_512 , modulus=x**_sage_const_512  + x**_sage_const_8  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 , names=('y',)); (y,) = E._first_ngens(1)
F = GF(_sage_const_2 **_sage_const_512 , modulus=x**_sage_const_512  + x**_sage_const_8  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 , names=('y',)); (y,) = F._first_ngens(1)

mod_512 = x**_sage_const_512  + x**_sage_const_8  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 

P = PolynomialRing(F, names=('z',)); (z,) = P._first_ngens(1)
f = z**_sage_const_512  + z**_sage_const_8  + z**_sage_const_5  + z**_sage_const_2  + _sage_const_1 


print(f.roots()[_sage_const_0 ])
poly = f.roots()[_sage_const_0 ][_sage_const_0 ].polynomial()

# int_value = sum([int(c) << i for i, c in enumerate(poly.coefficients(sparse=False))])
# print(f"0x{int_value:032x}")

poly_over_GF2 = R(poly)
# for i in range(1,512):
#     poly_pow = (poly_over_GF2**i) % mod_512
#     int_value = sum([int(c) << i for i, c in enumerate(poly_pow.coefficients(sparse=False))])
#     print(f"0x{int_value:032x}")
# for i in range(512):
#     poly_pow = (poly_over_GF2^i) % mod_512
#     coeffs = poly_pow.coefficients(sparse=False)
#     # Pad to 512 bits
#     coeffs += [0] * (512 - len(coeffs))
#     # Convert to integer
#     int_value = sum([int(c) << j for j, c in enumerate(coeffs)])
#     # Break into 16 32-bit words (little-endian order)
#     words = [(int_value >> (32 * j)) & 0xFFFFFFFF for j in range(16)]
#     word_strs = [f"0x{w:08x}" for w in words]
#     print("{" + ", ".join(word_strs) + "},")

for i in range(_sage_const_1 ,_sage_const_512 ):
    poly_pow = (poly_over_GF2**i) % mod_512
    coeffs = poly_pow.coefficients(sparse=False)
    coeffs += [_sage_const_0 ] * (_sage_const_512  - len(coeffs))
    
    # Convert bit list to 64 bytes (little-endian)
    bytes_le = []
    for j in range(_sage_const_0 , _sage_const_512 , _sage_const_8 ):
        byte = sum([int(coeffs[j + k]) << k for k in range(_sage_const_8 )])
        bytes_le.append(byte)
    
    # Format as C-style uint8 array
    byte_strs = [f"0x{int(b):02x}" for b in bytes_le]
    print("{" + ", ".join(byte_strs) + "},")


# print(hex(Integer(f.roots()[0][0].polynomial().integer_representation())))

#if False:
#    K.<x> = GF(2^4, modulus= X^4+X+1)
#    F = GF(2^128, 'y', modulus = X^128 + X^7 + X^2 + X + 1)
#    print(F, F.modulus())
#    print(F.gens())
#    H = Hom(K, F)
#    morph = H.list()[0]
#    g = morph.im_gens()[0]
#    print(morph)
#    y^14 + y^8 + y^7 + y^6 + y^3 + y^2 + 1
#    y^14 + y^8 + y^7 + y^6 + y^3 + y^2 + 1
#    y^14 + y^13 + y^11 + y^7 + 1

