

# This file was *autogenerated* from the file lin_frobenius_f2_sq_map.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_8 = Integer(8); _sage_const_5 = Integer(5); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)# # Step 1: Define the field GF(2^4)
# F.<a> = GF(2^4, modulus=x^4 + x + 1)  # You can change the modulus if needed

# # Step 2: List all elements in GF(2^4)
# elements = list(F)

# # Step 3: Define the square mapping: f(x) = x^2
# outputs = [x^2 for x in elements]

# # Step 4: Represent each element as a 4-bit vector (w.r.t basis 1, a, a^2, a^3)
# def element_to_vector(e):
#     return vector(GF(2), e.polynomial().coefficients(sparse=False) + [0]*(4 - len(e.polynomial().coefficients(sparse=False))))

# input_matrix = Matrix(GF(2), [element_to_vector(x) for x in elements])
# output_matrix = Matrix(GF(2), [element_to_vector(y) for y in outputs])

# # Step 5: Solve the linear system input_matrix * T = output_matrix
# # where T is the transformation matrix we want to find
# T = input_matrix.solve_left(output_matrix)

# print("Linear transformation matrix T such that T * input = output:")
# print(T)

# # Optional: Test the transformation
# for i in range(len(elements)):
#     inp = input_matrix[i]
#     expected = output_matrix[i]
#     computed = inp * T
#     assert computed == expected, f"Mismatch at index {i}"

# print("All checks passed. The transformation correctly maps x to x^2.")



# Step 1: Setup GF(2^512)
R = PolynomialRing(GF(_sage_const_2 ), 'x')
x = R.gen()
F = GF(_sage_const_2 **_sage_const_512 , name='a', modulus=x**_sage_const_512  + x**_sage_const_8  + x**_sage_const_5  + x**_sage_const_2  + _sage_const_1 )  # Choose any irreducible poly
a = F.gen()

# Step 2: Convert field element to 512-bit vector
def element_to_vector(e):
    coeffs = e.polynomial().coefficients(sparse=False)
    return vector(GF(_sage_const_2 ), coeffs + [_sage_const_0 ]*(_sage_const_512  - len(coeffs)))  # pad to 512

# Step 3: Build transformation matrix from squaring basis elements
basis = [a**i for i in range(_sage_const_512 )]  # [1, a, a^2, a^3, ....]
columns = [element_to_vector(b**_sage_const_2 ) for b in basis]
T = Matrix(GF(_sage_const_2 ), _sage_const_512 , _sage_const_512 , columns).transpose()

# Step 4: Display and test
print("512x512 linear transformation matrix for x ↦ x^2 over GF(2^512):")
# print(T)

# # Step 5: Check on all elements
# for e in F:
#     v = element_to_vector(e)
#     expected = element_to_vector(e^2)
#     actual = v * T
#     assert actual == expected, f"Error at {e}"
# print("All checks passed in GF(2^512).")

# Step 5: Emit the boolean equations in terms of x[i]
print("\n// Boolean equations for y = T * x")
for i in range(_sage_const_512 ):
    terms = [f"x[{j}]" for j in range(_sage_const_512 ) if T[i,j] == _sage_const_1 ]
    if terms:
        rhs = " + ".join(terms)
    else:
        rhs = "0"
    print(f"y[{i}] = {rhs};")




# # Step 1: Define GF(2^8)
# R = PolynomialRing(GF(2), 'x')
# x = R.gen()
# F = GF(2**8, name='a', modulus=x^8 + x^4 + x^3 + x + 1)  # Common irreducible poly (used in AES)
# a = F.gen()

# # Step 2: List all elements in GF(2^8)
# elements = list(F)

# # Step 3: Square each element
# outputs = [e^2 for e in elements]

# # Step 4: Convert each element to an 8-bit vector
# def element_to_vector(e):
#     coeffs = e.polynomial().coefficients(sparse=False)
#     return vector(GF(2), coeffs + [0]*(8 - len(coeffs)))

# input_matrix = Matrix(GF(2), [element_to_vector(e) for e in elements])     # 256x8
# output_matrix = Matrix(GF(2), [element_to_vector(e) for e in outputs])     # 256x8

# # Step 5: Solve the system to get 8x8 linear transformation matrix T
# T = input_matrix.solve_left(output_matrix)

# print("Linear transformation matrix T (for x ↦ x^2 over GF(2^8)):")
# print(T)

# # Step 6: Verify correctness
# for i in range(len(elements)):
#     assert input_matrix[i] * T == output_matrix[i]

# print("✅ All checks passed for GF(2^8).")



# # Step 1: Setup
# R = PolynomialRing(GF(2), 'x')
# x = R.gen()
# F = GF(2**8, name='a', modulus=x^8 + x^4 + x^3 + x + 1)
# a = F.gen()

# # Step 2: Convert a field element to 8-bit vector
# def element_to_vector(e):
#     coeffs = e.polynomial().coefficients(sparse=False)
#     return vector(GF(2), coeffs + [0]*(8 - len(coeffs)))

# # Step 3: Build the transformation matrix
# basis = [a^i for i in range(8)]  # Basis: 1, a, a^2, ..., a^7
# columns = [element_to_vector(b^2) for b in basis]
# T = Matrix(GF(2), 8, 8, columns).transpose()  # Columns → rows

# # Step 4: Display
# print("✅ 8x8 linear transformation matrix for x ↦ x^2 over GF(2^8):")
# print(T)

# # # Step 5: Test the transformation
# # for i in range(100):  # Test on random elements
# #     e = F.random_element()
# #     v = element_to_vector(e)
# #     expected = element_to_vector(e^2)
# #     actual = v * T
# #     assert actual == expected, f"Mismatch at {e}"
# # print("✅ Transformation verified on random elements.")

# # Step 5: Emit the boolean equations in terms of x[i]
# print("\n// Boolean equations for y = T * x")
# for i in range(8):
#     terms = [f"x[{j}]" for j in range(8) if T[i,j] == 1]
#     if terms:
#         rhs = " + ".join(terms)
#     else:
#         rhs = "0"
#     print(f"y[{i}] = {rhs};")

